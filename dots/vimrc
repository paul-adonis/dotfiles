" =============================  GENERAL CONFIG  ==============================
let mapleader=","               "Change leader to a comma
let maplocalleader = "\\"       "Change local leader to backslash
set encoding=utf-8

" win 120 80                    "Make window 80 wide x 45 tall
set nocompatible                "Use vim defaults
set ru                          "Turn on ruler
set number                      "Line numbers are good
set backspace=indent,eol,start  "Allow backspace in insert mode
set history=1000                "Store lots of :cmdline history
set showcmd                     "Show incomplete cmds down the bottom
set showmode                    "Show current mode down the bottom
set gcr=a:blinkon0              "Disable cursor blink
set visualbell                  "No sounds
set autoread                    "Reload files changed outside vim
set hidden                      "Buffers exist in the background
set ignorecase                  "Ignore case when searching
set wrapscan                    "Search wrap around the EOF
set smartcase                   "Override 'ignorecase' if search has uppercase
set incsearch                   "Do incremental searching
set hlsearch                    "Highlight searches
set nowrap                      "Don't wrap lines
set linebreak                   "Wrap lines at convenient points
set scrolloff=8                 "Start scrolling 8 lines away from margins
set sidescrolloff=15
set sidescroll=1
set shiftwidth=4
set softtabstop=4
set tabstop=4
set expandtab
set autochdir " always set pwd to path of current file
set clipboard=unnamed           "Allow vim to access OS clipboard
" set cin
" set autoindent
" set smartindent
" set smarttab

" Disable scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=l
set guioptions-=L

" =============================  INIT PLUGS  ==============================
if filereadable(expand("~/.vim/plugs.vim"))
  source ~/.vim/plugs.vim
endif


" highlight characters past 80 columns
augroup vimrc_autocmds
  autocmd BufEnter * highlight OverLength ctermbg=darkgrey guibg=#592929
  autocmd BufEnter * match OverLength /\%80v.*/
augroup END

set foldnestmax=5               "deepest fold is 5 levels
set foldmethod=syntax           "fold by syntax
" set foldmethod=indent          "fold based on indent
" set nofoldenable               "dont fold by default

" Display tabs and trailing spaces visually
set list listchars=tab:\ \ ,trail:·

" Keep undo history across sessions by storing it in a file
if has('persistent_undo')
  set undodir=~/.vim/undodir
  " Create dir if doesnt exist
  silent call system('mkdir -p ' . &undodir)
  set undofile
endif

" Auto complete stuff
set wildmode=list:longest,full     "first list:longest then full
set wildmenu                       "enable ctrl-n and ctrl-p to scroll thru matches
set wildignore=*.o,*.obj,*~        "stuff to ignore when tab completing
set wildignore+=*vim/backups*
set wildignore+=*sass-cache*
set wildignore+=*DS_Store*
set wildignore+=vendor/rails/**
set wildignore+=vendor/cache/**
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=tmp/**
set wildignore+=*.png,*.jpg,*.gif


" ================================  MAPPINGS  ==================================

" jj to exit insert mode
imap jj <Esc>

" Toggle fold open/closed with <S-Space> if over a fold
" nnoremap <silent> <S-Space> @=(foldlevel('.')?'za':'zc')<CR>
" nmap <S-Space> zc<CR>

" Move between split windows with Ctrl + arrow keys
nnoremap <silent> <C-h> <C-w>h
nnoremap <silent> <C-l> <C-w>l
nnoremap <silent> <C-k> <C-w>k
nnoremap <silent> <C-j> <C-w>j

" Make search results appear in middle of screen
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" Clear searches with ESC
nnoremap <esc> :noh<return><esc>
nnoremap <esc>^[ <esc>^[

nmap <Leader>vs :vsplit<CR>
nmap <Leader>s :split<CR>
nmap <Leader>c :close<CR>
nmap <Leader>w :w<CR>
nmap <Leader>wq :wq<CR>
nmap <Leader>q :q<CR>

" Remove unnecessary whitespace (trailing, between {}/quotes)
nnoremap <Leader>ww :let _s=@/
  \<Bar>:%s/\s\+$//e
  \<Bar>:%s/{ '/{'/e
  \<Bar>:%s/' }/'}/e
  \<Bar>:%s/{ "/{"/e
  \<Bar>:%s/" }/"}/e
  \<Bar>:let @/=_s<Bar><CR>

" ========================  VUNDLE/PLUGIN MAPPINGS  =========================

" Set some shortcuts for Tabularize
nmap <Leader>a= :Tabularize /=<CR>
vmap <Leader>a= :Tabularize /=<CR>
nmap <Leader>a: :Tabularize /:\zs<CR>
vmap <Leader>a: :Tabularize /:\zs<CR>

" NERDTree toggle set to capital T
map T :NERDTreeToggle<CR>
let g:NERDTreeWinSize = 20
let NERDTreeIgnore = ['\.pyc$','\.pyo$', '\.db$', '__pycache__']

" open NERDtree in console
let g:nerdtree_tabs_open_on_console_startup=1

" FZF (replacing Ctrl-P, FuzzyFinder and Command-T)

" --column: Show column number
" --line-number: Show line number
" --no-heading: Do not show file headings in results
" --fixed-strings: Search term as a literal string
" --smart-case: smart case search
" --no-ignore: Do not respect .gitignore, etc...
" --hidden: Search hidden files and folders
" --follow: Follow symlinks
" --glob: Additional conditions for search (in this case ignore everything in the .git/ folder)
" --color: Search color options
let g:rg_command = "
  \ rg --column --line-number --no-heading --fixed-strings --smart-case
  \ --follow --color 'always'
  \ --glob '!{.git,node_modules,vendor}/*'
  \ --glob '!*.java' --glob '!*.class' "
command! -bang -nargs=* Find
  \ call fzf#vim#grep(
  \     g:rg_command .shellescape(<q-args>), 1, <bang>0)

" command! -bang -nargs=* Rg
"   \ call fzf#vim#grep(
"   \   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
"   \   <bang>0)
nmap <Leader>f :Find<CR>

function! s:find_git_root()
  return system('git rev-parse --show-toplevel 2> /dev/null')[:-2]
endfunction
command! ProjectFiles execute 'Files' s:find_git_root()
nmap <Leader>t :ProjectFiles<CR>
nmap ; :Buffers<CR>

" Mappings for fugitive
map <leader>gb :Gblame<CR>
map <leader>gh :Gbrowse<CR>

" TComment remap to c key
map <leader>/ <c-_><c-_>

" Gundo - GUI Undo Tree (visualized)
map <leader>u :GundoToggle<CR>

" python folding - preview docstring in fold text
let g:SimpylFold_docstring_preview = 1

" set YouCompleteMe goto definition
" map <leader>g  :YcmCompleter GoToDefinitionElseDeclaration<CR>
" let g:ycm_autoclose_preview_window_after_completion = 1
" let g:ycm_autoclose_preview_window_after_insertion = 1

" make YCM compatible with UltiSnips (using supertab)
" let g:ycm_key_list_select_completion   = ['<C-j>', '<C-n>', '<Down>']
" let g:ycm_key_list_previous_completion = ['<C-k>', '<C-p>', '<Up>']
" let g:SuperTabDefaultCompletionType    = '<C-n>'
" let g:SuperTabCrMapping                = 0

" better key bindings for UltiSnipsExpandTrigger
" let g:UltiSnipsExpandTrigger = "<tab>"
" let g:UltiSnipsJumpForwardTrigger = "<tab>"
" let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" indent guide - minimum width, subtle highlighting
let g:indent_guides_guide_size = 1
let g:indent_guides_color_change_percent = 3
let g:indent_guides_enable_on_vim_startup = 1

" GitGutter
let g:gitgutter_sign_added = '∙'
let g:gitgutter_sign_modified = '∙'
let g:gitgutter_sign_removed = '∙'
let g:gitgutter_sign_modified_removed = '∙'
let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0

" ALE
let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
let g:ale_lint_on_text_changed = 'never'
highlight link ALEWarningSign String
highlight link ALEErrorSign Title

let g:ale_fixers = {
\   '*': ['remove_trailing_lines', 'trim_whitespace'],
\   'javascript': ['eslint'],
\}

" only lint on save, dont fix - we will do that
let g:ale_lint_on_save = 1
let g:ale_fix_on_save = 0

" run linting before saving to see changes
nmap <leader>d <Plug>(ale_fix)

" enable gutentags trace for debugging
" let g:gutentags_trace = 1

" disable polyglot when using latex
let g:polyglot_disabled = ['latex']

" Lightline
let g:lightline = {
\ 'colorscheme': 'wombat',
\ 'active': {
\   'left': [['mode', 'paste'], ['filename', 'modified']],
\   'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
\ },
\ 'component_expand': {
\   'linter_warnings': 'LightlineLinterWarnings',
\   'linter_errors': 'LightlineLinterErrors',
\   'linter_ok': 'LightlineLinterOK'
\ },
\ 'component_type': {
\   'readonly': 'error',
\   'linter_warnings': 'warning',
\   'linter_errors': 'error'
\ },
\ }

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()

" Update and show lightline but only if it's visible (e.g., not in Goyo)
function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction

" Need to set coloscheme after plugs are loaded
silent! colorscheme molokai

set bg=dark             "Options are 'dark' or 'light'
hi Folded guibg=#3e3e3e
hi Folded guifg=#b0b0b0

" enable true colors
set termguicolors

function! s:goyo_enter()
    colorscheme pencil
endfunction

function! s:goyo_leave()
    colorscheme molokai
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()
